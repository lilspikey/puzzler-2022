#!/usr/bin/env python3

import argparse
import os
import random
import re
from collections import defaultdict


WORDS_GIST_URL = 'https://gist.githubusercontent.com/dracos/dd0668f281e685bad51479e5acaadb93/raw/ca9018b32e963292473841fb55fd5a62176769b5/valid-wordle-words.txt'
CORRECT_SPOT = 'ðŸŸ©'
WRONG_SPOT = 'ðŸŸ¨'
NO_SPOT = 'â¬œ'
CORRECT_GUESS = CORRECT_SPOT * 5


def load_words():
    words_file = 'valid-wordle-words.txt'
    if not os.path.exists(words_file):
        from urllib.request import urlopen
        words = urlopen(WORDS_GIST_URL).read().decode('utf8')
        with open(words_file, 'w') as f:
            f.write(words)
    with open(words_file, 'r') as f:
        return [word.strip() for word in f.readlines()]


def score_guess(word, guess):
    """
    >>> score_guess("alien", "alien")
    'ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©'
    >>> score_guess("alley", "alien")
    'ðŸŸ©ðŸŸ©â¬œðŸŸ©â¬œ'
    >>> score_guess("alien", "alley")
    'ðŸŸ©ðŸŸ©â¬œðŸŸ©â¬œ'
    >>> score_guess("alien", "shove")
    'â¬œâ¬œâ¬œâ¬œðŸŸ¨'
    >>> score_guess("hoove", "shove")
    'â¬œðŸŸ¨ðŸŸ©ðŸŸ©ðŸŸ©'
    >>> score_guess("hoove", "odour")
    'ðŸŸ¨â¬œðŸŸ©â¬œâ¬œ'
    """
    score = [None] * len(word)
    not_exact = set()
    for i, w in enumerate(word):
        g = guess[i]
        if g == w:
            score[i] = CORRECT_SPOT
        else:
            not_exact.add(w)
    for i, w in enumerate(word):
        g = guess[i]
        if g != w:
            if g in not_exact:
                score[i] = WRONG_SPOT
            else:
                score[i] = NO_SPOT
    return ''.join(score)


def run_wordle(answer, words, guesser):
    guess_num = 0
    to_send = None
    while guess_num < 6:
        score = err = None
        if to_send is None:
            guess = next(guesser)
        else:
            guess = guesser.send(to_send)
        if not re.match(r'[a-zA-Z]{5}', guess):
            err = "invalid guess"
        elif guess not in words:
            err = "not in word list"
        else:
            err = None
            score = score_guess(answer, guess)
            guess_num += 1
            if guess == answer:
                break
        to_send = (guess_num, score, None, err)
    guesser.send((guess_num, score, answer, err))


def overlap_with_other_words(by_position_letter, word):
    overlap = 0
    for i, w in enumerate(word):
        overlap += len(by_position_letter[(i, w)])
    return overlap


def choose_candidate_word(by_position_letter, words):
    words = list(words)
    score = lambda w: len(set(w)) * overlap_with_other_words(by_position_letter, w)
    words.sort(key=score)
    word = words[-1]
    verbose("score", word, score(word))
    return word


def by_position_letter_index(words):
    by_position_letter = defaultdict(set)
    for word in words:
        for i, w in enumerate(word):
            by_position_letter[(i, w)].add(word)
    return by_position_letter


def interactive():
    while True:
        result = yield input(">")
        if result:
            guess_num, score, answer, err = result
            
            if err:
                print(err)
            else:
                print(guess_num, score)

            if score == CORRECT_GUESS:
                break
            elif answer:
                print(answer)
                break
    yield


def automatic(words):
    by_position_letter = by_position_letter_index(words)
    guess = choose_candidate_word(by_position_letter, words)
    current_words = set(words)
    while True:
        result = yield guess
        if result:
            verbose(result)
            guess_num, score, answer, err = result
            print(guess)
            print(guess_num, score)
            if score == CORRECT_GUESS:
                break
            elif answer:
                print(answer)
                break
            if score:
                available_positions = []
                for i, s in enumerate(score):
                    if s != CORRECT_SPOT:
                        available_positions.append(i)
                for i, s in enumerate(score):
                    g = guess[i]
                    if s == CORRECT_SPOT:
                        current_words = current_words & by_position_letter[(i, g)]
                    elif s == WRONG_SPOT:
                        current_words = current_words - by_position_letter[(i, g)]
                        other_postions = [p for p in available_positions if p != i and guess[p] != g]
                        other_spot_words = set()
                        for pos in other_postions:
                            other_spot_words = other_spot_words | by_position_letter[(pos, g)]
                        current_words = current_words & other_spot_words
                    elif s == NO_SPOT:
                        for pos in available_positions:
                            current_words = current_words - by_position_letter[(pos, g)]
                    verbose(len(current_words))
                by_position_letter = by_position_letter_index(current_words)
                guess = choose_candidate_word(by_position_letter, current_words)
    yield

    


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("--doc-test", action="store_true")
    parser.add_argument("--guesser", choices=["interactive", "automatic"], default="interactive")
    parser.add_argument("--verbose", action="store_true")

    args = parser.parse_args()
    if args.verbose:
        verbose = print
    else:
        def verbose(*arg, **kw):
            pass

    if args.doc_test:
        import doctest
        doctest.testmod(verbose=True)
    else:
        words = load_words()
        word = random.choice(words)
        try:
            if args.guesser == "interactive":
                guesser = interactive()
            else:
                guesser = automatic(words)
            run_wordle(word, set(words), guesser)
        except (EOFError, KeyboardInterrupt) as e:
            pass

